# 进程基本概念

官方：进程是担当分配系统资源的实体

实质：PCB（process control block，在 LINUX 下即为 task_struct） + 代码和相关数据

# 进程属性

1. PID(process ID): 进程编号
2. EXE: 进程内相关的程序（.exe文件）的路径
3. CWD(current work direction): 当前工作路径，也就是进程内创建文件的默认路径
4. PPID(parent PID): 父进程的 PID
5. PRI(priority): default(一般是80) + nice
 
    nice调整范围: [-20, 19] (太大容易影响调度公平)
    nice的调整不具备历史性，对 nice 做调整就只是调整 nice，可以将 default 想象成**const int**，nice是一个**int**，我们只是在修改变量nice的值。
6. UID(用户ID): 该进程是由哪个用户发起的，UID记录的是该用户的ID。有了UID，进程就能查看用户的权限，从而做权限管理。(表现：执行命令时报错，说明权限不足)。


# 创建子进程

## 相关性质

进程之间具有独立性，互不干扰。（手段）
这样可以更安全地管理资源。（目的）

但是，父子进程之间虽然**不共用数据**，但是会**共用同一套代码**
，因为代码是**只读**的，共用代码不会影响独立性。

## fork(system call) 创建子进程

**pid_t fork(void);**

fork 函数可以创建子进程，在父进程处返回**子进程的PID**，在子进程处返回 0

```c
pid_t fork() {
    // 将父进程的 PCB 复制一份
    // 调整复制好的 PCB，作为子进程的 PCB
    // 将调整好的 PCB 连入进程列表（此时，子进程就算是创建好了）

    // 父进程调用完 fork 会得到子进程的 PID
    // 子进程调用该 fork 得到了 0 
    // 此处不是 fork 函数返回了两个值，而是分别被父子进程调用了一次，共被调用两次
    return id;
}
```

# 并行和并发

    并行：多个进程分别在多个 CPU 下同时运行

    并发：多个进程在同一个 CPU 下采用进程切换的方式运行，在一段时间内，让多个进程都得以推进。

# 时间片和分时操作系统

    时间片：OS 分配给进程的**一段固定的CPU时间**，时间一到，就切走当前进程。

    分时操作系统：追求调度任务公平。通过**时间片轮转**，让多个进程被轮流调度，从而保障公平。