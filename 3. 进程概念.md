# 进程基本概念

官方：进程是担当分配系统资源的实体

实质：PCB（process control block，在 LINUX 下即为 task_struct） + 代码和相关数据

# 进程属性

1. PID(process ID): 进程编号
2. EXE: 进程内相关的程序（.exe文件）的路径
3. CWD(current work direction): 当前工作路径，也就是进程内创建文件的默认路径
4. PPID(parent PID): 父进程的 PID
5. PRI(priority): default(一般是80) + nice
 
    nice调整范围: [-20, 19] (太大容易影响调度公平)
    nice的调整不具备历史性，对 nice 做调整就只是调整 nice，可以将 default 想象成**const int**，nice是一个**int**，我们只是在修改变量nice的值。

    PRI范围：[60, 99], 共40种，这是因为可供用户控制的优先级刚好有40种。

6. UID(用户ID): 该进程是由哪个用户发起的，UID记录的是该用户的ID。有了UID，进程就能查看用户的权限，从而做权限管理。(表现：执行命令时报错，说明权限不足)。

# 进程链接属性
##

```c++
struct run_node {
    struct run_node* pre;
    struct run_node* next;
}
```

1. 普及：储存进程的队列**往往以双向链表的方式存储**。
2. 进程可能存在多个队列中（如同时在运行队列和全局队列中），同时为了兼顾代码的可读性和易扩展的性质，在PCB中存入多种**node（如run_node, wait_node, start_node）**, 每一种node中**只包含链接关系**。
3. 每一种链接关系中的指针指向的不是进程，而是另一个进程中的对应的链接关系，这样有很好的代码结构，链接就只需要考虑链接了。
## 问题：怎么跳转到下一个进程呢？
### 建模
```c++
struct {
    int a;
    int b;
    int c;
    ...
}A;
```
假设 A.c的地址为p1，A的地址为p2。

如何通过p1求解p2？

### 解决方法：偏移量
1. p2 相对于 p1的偏移量(设为x)：``` &((A*)0->c) ```
2. p2 == ``` p1 - x ```

# 创建子进程

## 相关性质

进程之间具有独立性，互不干扰。（手段）
这样可以更安全地管理资源。（目的）

但是，父子进程之间虽然**不共用数据**，但是会**共用同一套代码**
，因为代码是**只读**的，共用代码不会影响独立性。

## fork(system call) 创建子进程

**pid_t fork(void);**

fork 函数可以创建子进程，在父进程处返回**子进程的PID**，在子进程处返回 0（子进程直接从 fork 处开始运行）

```c
pid_t fork() {
    // 将父进程的 PCB 复制一份
    // 调整复制好的 PCB，作为子进程的 PCB
    // 将调整好的 PCB 连入进程列表（此时，子进程就算是创建好了）

    // 此时父子进程都在这里（return 处），返回时分别获取到不同的值
    return id;
}
```