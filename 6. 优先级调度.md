# 引入
进程都有优先级，可以根据优先级决定队列，参考**priority_queue**, 但是调度是非常频繁的，我们需要一个时间消耗为常数，且常数还得小的数据结构。所以，不能采用堆的设计.

# 类似于哈希桶的处理方案
```c++
    struct queue {
        // 100 个位置属于系统，其余40个属于用户
        // queue[i] : 指向优先级为 i 的链表（就像是挂哈希桶一样）
        task_struct* q[140]; 

        // 用5 * 32个bit位，表示每一种优先级是否有进程。
        int bitmap[5];

        // 当前表中的进程个数
        int nr_active;

        // 插入 PCB
        void insert(PCB) {
            q[PCB.PRI + 40].push(PCB);
        }

        // 返回最高的非空优先级 
        int func() {
            for (int i = 0; i < 5; ++i) {
                if (bitmap[i] != 0) {
                    int x = lowbit(bitmap[i])；

                    // hash[x] : x 对应第几位，这样的映射很容易做到。
                    return i * 32 + hash[x];
                }
            }
        }
    }
```


1. 插入：``` q[PCB.PRI + 40].push(PCB) ```(作用域在结构体内部)，在队列中插入，明显O(1).
2. 取元素：从高优先级到低优先级遍历，直到发现进程，但是时间常数大，为140，这不是我们想要的效率。
3. lowbit 优化取元素，不难发现，常数降到了5，而且这是最坏的情况，这才是我们想要的O(1)调度。

# 饥饿问题

## 调度的三种可能
1. 退出（不重要）
2. 未退出，但时间片到了
3. 产生新的进程

## 饥饿问题是什么？
优先级较低的进程难以调度的问题
## 为什么有饥饿问题？
不妨设老进程为A，等待的进程为B

1. A时间片到，应当轮转到B。但之所以A比B先调度，就是因为A的优先级高，如果把A直接放入队列中，那么下一个调度的很可能还是A，形成恶性循环。
2. 大量高优先的进程持续插入，B一直排队，难以调度。

## 怎么办？
```c++
    struct RunQueue {
        struct queue* active; // 活跃的（当前队列）
        struct queue* expired; // 过期的
        struct queue array[2]; // 两个队列
        ......
    }
```

1. 解决方案：在RunQueue中放置两个队列，新进程和时间片到了的进程插入到过期队列中，等当前队列空了，轮转到另一个队列。
2. 队列判空: ``` nr_active == 0; ```
3. 轮转方法：``` swap(active, expired); ```